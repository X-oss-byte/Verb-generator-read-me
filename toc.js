'use strict';

var extend = require('extend-shallow');
var through = require('through2');
var toc = require('markdown-toc');

module.exports = function(verb) {
  verb.postLayout(/\.md/, function(file, next) {
    var opts = extend({}, verb.options, file.options);
    if (opts.toc !== true) {
      next();
      return;
    }
    file.toc = toc(file.content, opts);
    next();
  });

  verb.preWrite(/\.md/, function(file, next) {
    var opts = extend({}, verb.options, file.options);
    var str = file.contents.toString();

    var tocString = (file.toc && file.toc.content) || '';
    if (tocString === '' || opts.toc !== true) {
      str = str.replace(/^#+ TOC/gm, '');
      tocString = '';
    } else {
      tocString += '\n\n_(TOC generated by [verb](https://github.com/verbose/verb))_';
    }

    str = str.split('<!-- toc -->').join(tocString);
    str = str.replace(/\n{2,}/g, '\n\n');
    file.contents = new Buffer(str);
    next();
  });

  verb.plugin('toc.create', function(options) {
    return through.obj(function(file, enc, next) {
      var opts = extend({}, verb.options, options, file.options);
      if (opts.toc !== true) {
        return next(null, file);
      }
      file.toc = toc(file.content, opts);
      next(null, file);
    });
  });

  verb.plugin('toc.inject', function(options) {
    return through.obj(function(file, enc, next) {
      var opts = extend({}, verb.options, options, file.options);
      var str = file.contents.toString();

      var tocString = (file.toc && file.toc.content) || '';
      if (tocString === '' || opts.toc !== true) {
        str = str.replace(/^#+ TOC/gm, '');
        tocString = '';
      } else {
        tocString += '\n\n_(TOC generated by [verb](https://github.com/verbose/verb))_';
      }

      str = str.split('<!-- toc -->').join(tocString);
      str = str.replace(/\n{2,}/g, '\n\n');
      file.contents = new Buffer(str);
      next(null, file);
    });
  });
};
