'use strict';

var fs = require('fs');
var path = require('path');
var templates = path.resolve.bind(path, __dirname, 'templates');
var debug = require('debug')('base:verb:verb-readme-generator');
var depdocs = require('./lib/depdocs');
var helpers = require('./lib/helpers');
var utils = require('./lib/utils');
var lint = require('./lib/lint');

/**
 * Verb readme generator
 */

function generator(app, base) {
  if (!utils.isValid(app, 'verb-readme-generator')) return;
  setAppContext(app);

  /**
   * Engine
   */

  app.engine('hbs', require('engine-handlebars'));
  app.handler('prePipeline');

  /**
   * User's CWD
   */

  var cwd = path.resolve.bind(path, app.cwd);
  // get verb config object from package.json
  var config = app.base.get('cache.config') || {};

  /**
   * Helpers
   */

  helpers(app);
  depdocs(app);
  app.helpers(require('template-helpers')());

  /**
   * Set options
   */

  app.option(app.pkg.get('verb') || {});
  app.option('toc.footer', '\n\n_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_');
  app.option('engineOpts', {delims: ['{%', '%}']});
  app.option('toAlias', function readme(name) {
    if (/^verb-.*?-\w/.test(name)) {
      return name.replace(/^verb-(.*?)-(?:\w+)/, '$1');
    }
    return name.slice(name.lastIndexOf('-') + 1);
  });

  app.option('toc.linkify', function(token, name, slug, tocOpts) {
    if (/[{<]%=?/.test(name)) {
      var inst = new app.constructor();
      var opts = app.options;
      var engine = app.getEngine('*') || app.getEngine('md');
      inst.engine('*', engine);
      opts.engine = '*';
      inst.data(app.cache.data);
      var view = inst.view('toctemp.md', {content: name, layout: false});
      inst.compile(view, opts);
      token.content = view.fn(inst.cache.data);
    }
    utils.toc.linkify(token, name, slug, tocOpts);
    return token;
  });

  /**
   * Plugins
   */

  app.use(utils.conflicts());
  app.use(require('verb-defaults'));
  app.use(require('verb-collections'));
  app.use(require('verb-repo-helpers'));
  app.use(require('verb-repo-data'));
  app.use(require('verb-toc'));
  app.use(utils.questions());
  app.use(utils.loader());
  app.use(utils.pkg());

  /**
   * Generate `README.md` and fix missing [reflinks](#reflinks).
   *
   * ```sh
   * $ verb readme
   * ```
   * @name readme
   * @api public
   */

  app.task('readme', ['readme-build', 'readme-reflinks']);

  /**
   * Alias for the [readme]() task, generates a README.md to the user's working directory.
   *
   * ```sh
   * $ verb readme
   * ```
   * @name default
   * @api public
   */

  app.task('default', {silent: true}, ['readme']);

  /**
   * Initialize middleware used for rendering the [readme](#readme).
   *
   * ```sh
   * $ verb readme:readme-middleware
   * ```
   * @name readme-middleware
   * @api public
   */

  app.task('readme-middleware', { silent: true }, function(cb) {
    if (app.option('sections')) {
      app.onLoad(/\.md$/, require('./lib/sections')(app));
    }

    app.preRender(/(verb|readme)\.md$/i, function(file, next) {
      utils.del(path.resolve(app.cwd, 'readme.md'), next);
    });

    app.onLoad(/(verb|readme)\.md$/, lint.layout(app));
    cb();
  });

  /**
   * Loads data to used for rendering templates. Called by the [readme]() task.
   *
   * ```sh
   * $ verb readme:readme-data
   * ```
   * @name readme-data
   * @api public
   */

  app.task('readme-data', { silent: true }, function(cb) {
    debug('loading data');

    // temporary data
    app.data({
      links: {
        verb: {
          repo: 'https://github.com/verbose/verb',
          bugs: 'https://github.com/verbose/verb/issues',
          getting_started: 'https://github.com/verb/getting-started'
        },
        generate: {
          repo: 'https://github.com/generate/generate',
          bugs: 'https://github.com/generate/generate/issues',
          getting_started: 'https://github.com/generate/getting-started'
        },
        update: {
          repo: 'https://github.com/update/update',
          bugs: 'https://github.com/update/update/issues',
          getting_started: 'https://github.com/update/getting-started'
        }
      }
    });

    if (!app.cache.data.verb) {
      app.data({verb: {}});
    }

    if (!app.has('cache.data.verb.related.list')) {
      app.data({
        verb: {related: {list: []}}
      });
    }

    if (utils.exists(cwd('bower.json'))) {
      app.data({bower: true});
    }

    if (app.isGenerator) {
      app.option('toAlias', function(name) {
        return utils.camelcase(name.replace(/^generate-/, ''));
      });
    }

    app.data('name', app.pkg.get('name') || app.cache.data.name);
    app.data({prefix: 'Copyright'});
    debug('data finished');
    cb();
  });

  /**
   * Load layouts, includes and badges commonly used for generating a README.md.
   *
   * ```sh
   * $ verb readme:readme-templates
   * ```
   * @name readme-templates
   * @api public
   */

  app.task('readme-templates', { silent: true }, function(cb) {
    debug('loading templates');

    app.option('renameKey', function(key, file) {
      var name = file ? file.relative : path.relative(app.cwd, key);
      var ext = path.extname(name);
      var str = name.replace(/^(templates|docs)\/?(layouts|includes)\/?/, '');
      return ext ? str.slice(0, str.length - ext.length) : str;
    });

    // load `docs` templates in user cwd
    app.docs('*.md', {cwd: templates('docs')});
    if (utils.exists(cwd('docs')) && app.pkg.get('verb.options.docs') !== false) {
      app.docs('*.md', {cwd: path.resolve(app.cwd, 'docs')});
    }

    // load `layout` templates
    app.layouts('*.md', { cwd: templates('layouts') });

    // load `include` templates
    app.includes('**/*.md', { cwd: templates('includes') });
    app.includes(require('./templates/includes'));
    if (utils.exists(cwd('docs'))) {
      app.includes('*.md', {cwd: cwd('docs')});
    }

    // load `badges` templates
    app.badges(require('./templates/badges'));
    if (typeof config.views === 'undefined') {
      cb();
      return;
    }

    // call `.config.process` again to override built-in templates
    // with any templates defined in `package.json`
    app.config.process({views: config.views}, function(err) {
      if (err) return cb(err);
      debug('templates finished');
      cb();
    });
  });

  /**
   * Load `options`, `plugins`, `middleware` and `data` before calling a task
   * to render templats.
   *
   * ```sh
   * $ verb readme:readme-setup
   * ```
   * @name readme-setup
   * @api public
   */

  app.task('readme-setup', {silent: true}, ['readme-middleware', 'readme-data', 'readme-templates']);

  /**
   * Run after other tasks to get any missing reflinks found in rendered markdown
   * documents, and add them to the `verb.reflinks` array in package.json. Verb
   * uses this array to generate reflinks so that missing reflinks will still resolve.
   *
   * ```sh
   * $ verb readme:readme-reflinks
   * ```
   * @name readme-reflinks
   * @api public
   */

  app.task('readme-reflinks', {silent: true}, function(cb) {
    var existing = app.pkg.get('verb.reflinks') || [];
    var reflinks = app.get('cache.reflinks') || [];
    var diff = utils.diff(reflinks, existing);

    if (diff.length > 1) {
      app.pkg.union('verb.reflinks', diff);
      app.pkg.save();
      app.pkg.logInfo('updated package.json with:', {reflinks: diff});
    }
    cb();
  });

  /**
   * Generate a README.md from a `.verb.md` template. Runs the [setup](), and [verbmd]() tasks.
   * This is a [verb][docs]{tasks.md#silent} task.
   *
   * ```sh
   * $ verb readme:readme-build
   * ```
   * @name readme-build
   * @api public
   */

  app.task('readme-build', {silent: true}, ['readme-setup', 'verbmd'], function(cb) {
    debug('starting readme task');
    var srcBase = app.options.srcBase || app.cwd;
    var readme = path.resolve(srcBase, app.options.readme || '.verb.md');

    app.data(app.base.cache.data);
    app.helpers(app.base._.helpers.async);
    app.helpers(app.base._.helpers.sync);

    app.toStream('files', utils.filter(readme)).on('error', cb)
      .pipe(app.renderFile('hbs', app.cache.data)).on('error', cb)
      .pipe(app.renderFile('*', app.cache.data)).on('error', cb)
      .pipe(utils.handle(app, 'prePipeline')).on('error', cb)
      .pipe(utils.reflinks(app.options))
      .pipe(app.pipeline(app.options.pipeline)).on('error', cb)
      .pipe(app.dest(function(file) {
        app.union('cache.reflinks', file._reflinks);
        file.basename = 'README.md';
        return app.cwd;
      }))
      .on('error', cb)
      .on('end', cb);
  });

  /**
   * Load the `.verb.md` in the user's current working directory. If no `.verb.md`
   * file exists, the [prompt-verbmd)() task is called to ask the user if they want to
   * add the file. Disable the prompt by passing `--verbmd=false` on the command line,
   * or `app.disable('verbmd')` via API.
   *
   * ```sh
   * $ verb readme:verbmd
   * ```
   * @name verbmd
   * @api public
   */

  app.task('verbmd', { silent: true }, function(cb) {
    debug('loading .verb.md');
    if (app.views.files['README'] || app.views.files['.verb'] || app.options.verbmd === false) {
      cb();
      return;
    }

    // try to load ".verb.md" or custom file from user cwd
    var srcBase = app.options.srcBase || app.cwd;
    var readme = path.resolve(srcBase, app.options.readme || '.verb.md');
    if (utils.exists(readme)) {
      app.file('README.md', readTemplate(app, readme, srcBase));
      cb();
      return;
    }
    app.build('verbmd-prompt', cb);
  });

  /**
   * Generate a new `.verb.md` template to the current working directory.
   *
   * ```sh
   * $ verb readme:new
   * # also aliased as
   * $ verb readme:verbmd-new
   * ```
   * @name verbmd-new
   * @api public
   */

  app.task('new', ['verbmd-new']);
  app.task('verbmd-new', function() {
    var dest = path.resolve(app.option('dest') || app.cwd);
    app.file('.verb.md', readTemplate(app, 'verbmd/basic.md'));
    return app.toStream('files')
      .pipe(app.conflicts(dest))
      .pipe(app.dest(function(file) {
        file.base = dest;
        file.path = path.resolve(file.base, '.verb.md');
        return dest;
      }));
  });

  /**
   * Prompts the user to add a new `.verb.md` template to the current working directory.
   * Useful in sub-generators.
   *
   * ```sh
   * $ verb readme:verbmd-prompt
   * # alias aliased as
   * $ verb readme:ask
   * ```
   * @name verbmd-prompt
   * @api public
   */

  app.task('verbmd-prompt', function(cb) {
    // if no .verb.md exists, offer to add one
    app.confirm('verbmd', 'Can\'t find a .verb.md, want to add one?');
    app.ask('verbmd', { save: false }, function(err, answers) {
      if (err) return cb(err);
      if (answers.verbmd) {
        app.build('new', cb);
      } else {
        cb();
      }
    });
  });

  return generator;
}

function setAppContext(app) {
  var name = app.pkg.get('name');
  var platform = {};

  if (/^base-?/.test(name)) {
    platform.repo = 'node-base/base';
    platform.docs = `https://github.com/${platform.repo}/blob/master/docs`;
    platform.proper = 'Base';
    platform.name = 'base';
    platform.command = 'base';
    platform.configname = 'basefile';
    platform.configfile = 'basefile.js';
  } else if (/^assemble-?/.test(name)) {
    platform.repo = 'assemble/assemble';
    platform.docs = `https://github.com/${platform.repo}/blob/master/docs`;
    platform.proper = 'Assemble';
    platform.name = 'assemble';
    platform.command = 'assemble';
    platform.configname = 'assemblefile';
    platform.configfile = 'assemblefile.js';
  } else if (/^generate-?/.test(name)) {
    platform.repo = 'generate/generate';
    platform.docs = `https://github.com/${platform.repo}/blob/master/docs`;
    platform.proper = 'Generate';
    platform.name = 'generate';
    platform.command = 'gen';
    platform.configname = 'generator';
    platform.configfile = 'generator.js';
  } else if (/^(updater-?|update)/.test(name)) {
    platform.repo = 'update/update';
    platform.docs = `https://github.com/${platform.repo}/blob/master/docs`;
    platform.proper = 'Update';
    platform.name = 'update';
    platform.command = 'update';
    platform.configname = 'updater';
    platform.configfile = 'updatefile.js';
  } else if (/^verb-?/.test(name)) {
    platform.repo = 'verbose/verb';
    platform.docs = `https://github.com/${platform.repo}/blob/master/docs`;
    platform.proper = 'Verb';
    platform.name = 'verb';
    platform.command = 'verb';
    platform.configname = 'verbfile';
    platform.configfile = 'verbfile.js';
  }
  app.data('platform', platform);
  app.base.data('platform', platform);
}

/**
 * Read a template
 *
 * @param {Object} `verb`
 * @param {String} `fp`
 * @param {String} `base`
 * @return {String}
 */

function readTemplate(app, filepath, base) {
  var dir = base || app.env.templates || templates();
  var absolute = path.resolve(path.resolve(dir), filepath);
  return {
    contents: fs.readFileSync(absolute),
    path: absolute
  };
}

/**
 * Expose `generator`
 */

module.exports = generator;
