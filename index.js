'use strict';

var fs = require('fs');
var path = require('path');
var debug = require('debug')('base:verb:generator');
var utils = require('./utils');

module.exports = function(app, base) {
  app.extendWith(require('gen-defaults'));
  app.extendWith(require('verb-toc'));

  /**
   * Set options
   */

  app.option('engine.delims', ['{%', '%}']);
  app.option('toc.footer', '\n\n_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_');

  /**
   * Load data to be passed to templates at render time
   */

  app.task('data', function(cb) {
    debug('loading data');

    app.data('alias', 'readme');
    var runner = base.cache.data.runner;
    runner.url = runner.homepage;
    app.data({runner: runner});

    // this needs work, we need to also merge in globally persisted values
    var person = expandPerson(app.data('author'));
    app.data({author: person});

    // Create a license statement from license in from package.json
    app.data(formatLicense(app));
    debug('data finished');
    cb();
  });

  /**
   * Helpers
   */

  app.task('helpers', function(cb) {
    debug('loading helpers');

    app.asyncHelper('related', utils.related({verbose: true}));
    app.asyncHelper('reflinks', utils.reflinks({verbose: true}));
    app.asyncHelper('pkg', function(name, prop, cb) {
      if (typeof prop === 'function') {
        cb = prop;
        prop = null;
      }
      utils.getPkg(name, function(err, pkg) {
        if (err) return cb(err);
        cb(null, prop ? utils.get(pkg, prop) : pkg);
      });
    });

    app.helper('apidocs', utils.apidocs());
    app.helper('date', utils.date);
    app.helper('copyright', utils.copyright({linkify: true}));
    app.helper('issue', function(options) {
      var opts = utils.extend({}, this.context, options);
      opts.owner = opts.owner || opts.author && opts.author.username;
      opts.repo = opts.name;
      return utils.issue(opts);
    });

    debug('helpers finished');
    cb();
  });

  /**
   * Templates
   */

  app.task('templates', ['helpers', 'data'], function(cb) {
    debug('loading templates');

    // create badges collection
    app.create('badges', {viewType: 'partial', engine: '*' });

    // load .verb.md from user cwd
    if (fs.existsSync(path.resolve(app.cwd, '.verb.md'))) {
      app.doc('readme.md', {contents: read(app, '.verb.md', app.cwd)});
    } else {
      app.doc('readme.md', {contents: read(app, '.verb.md'), layout: 'default'});
    }

    // load layout templates
    app.layouts('templates/layouts/*.md', {cwd: __dirname});

    // load include templates
    app.includes(require('./templates/includes'));
    app.badges(require('./templates/badges'));

    debug('templates finished');
    cb();
  });

  /**
   * Readme task
   */

  app.task('readme', ['defaults', 'templates'], function(cb) {
    debug('starting readme task');

    return app.src('.verb.md', { cwd: app.cwd })
      .on('error', console.log)
      .pipe(app.renderFile('*'))
      .on('error', console.log)
      .pipe(app.pipeline(app.options.pipeline))
      .pipe(app.dest(function(file) {
        file.basename = 'readme.md';
        return app.cwd;
      }));
  });

  app.task('default', ['readme']);
};

/**
 * Read a template
 *
 * @param {Object} `verb`
 * @param {String} `fp`
 * @param {String} `cwd`
 * @return {String}
 */

function read(app, fp, cwd) {
  cwd = cwd || app.env.templates || path.join(__dirname, 'templates');
  return fs.readFileSync(path.resolve(cwd, fp));
}

/**
 * Add "Released under..." statement to license from
 * package.json.
 *
 * @param {Object} `verb`
 * @return {undefined}
 */

function formatLicense(app) {
  var license = app.data('license') || 'MIT';
  var fp = path.resolve(app.cwd, 'LICENSE');
  if (fs.existsSync(fp)) {
    var url = repoFile(app.data('repository'), 'LICENSE');
    license = '[' + license + ' license](' + url + ').';
  } else {
    license += ' license.';
  }
  return { license: 'Released under the ' + license };
}

/**
 * Format the github url for a filepath
 *
 * @param {String} `repo`
 * @param {String} `filename`
 * @return {String}
 */

function repoFile(repo, filename) {
  return 'https://github.com/' + repo + '/blob/master/' + filename;
}

/**
 * Expand person strings into objects
 */

function expandPerson(str) {
  var person = {};
  if (Array.isArray(str)) {
    str.forEach(function(val) {
      person = utils.extend({}, person, utils.parseAuthor(val));
    });
  } else if (typeof str === 'string') {
    person = utils.extend({}, person, utils.parseAuthor(str));
  } else if (str && typeof str === 'object') {
    person = utils.extend({}, person, str);
  }

  if (!person.username && person.url && /github\.com/.test(person.url)) {
    person.username = person.url.slice(person.url.lastIndexOf('/') + 1);
  }
  if (!person.twitter && person.username) {
    person.twitter = person.username;
  }
  return utils.omitEmpty(person);
}
